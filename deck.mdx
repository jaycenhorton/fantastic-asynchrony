export { default as themes } from './theme';

import { Notes, Image } from 'mdx-deck';

## Fantastic Asynchrony and How to Find It

---

# The problem

Creating asynchrony is easy.

Coordinating asynchrony is hard.

Distributing asynchrony is harder.

<Notes>
  It is often desired to trigger additional jobs based on an initial operation.
  Often, those jobs require a chain of async/await calls to execute sequentially
  in order to look up relevant properties for use in the newly spawned jobs.
  Unfortunately, due to the way JS's event loop works, consuming async/await to
  look up the data for those additional jobs would cause a delay in the initial
  job's finalization. As such, a pattern is needed to spawn new tasks in
  entirely different contexts.
</Notes>

---


# Creating asynchrony is easy.


---
 “Let there be light”

---

<Image  size="50%" src="images/0.png"/>


---


import { SplitRight } from 'mdx-deck/layouts'

export default SplitRight



<div style={{width:"90%"}}>

```typescript

// Entity.ts

interface EntityObject {
  [name: string]: any;
}

class Entity<T extends EntityObject> {
  public static readonly kind: string;
  protected readonly data: T;

  constructor(data: T, req?: IViewerContext) {
    this.data = data;
  }

  async update<T extends object, E extends Entity<T>>(
    newData: T,
    req?: IViewerContext
  ) {
    const entityData: object = {
      ...(<object>this.data),
      ...(<object>newData),
      dateLastUpdated: new Date(Date.now()),
    };
    const [response] = await GCloudDB().update(entityData);
    return <E>new (<typeof Entity>this.constructor)(entityData, req);
  }

}

```
</div>

<img style={{width:"90%"}}  src="images/0.png"/>


---

<img style={{width:"45%"}}  src="images/1.png"/>
<div style={{width:"30%",  margin: "auto"}}>

```typescript

const entity = new Entity({}); // create the entity

(async () =>
  entity.update({data:"some data"}))() // trigger an update to the entity

```
</div>

---

<Image size="50%" src="images/3.png"/>

---

<Image size="50%" src="images/4.png"/>

---

export default SplitRight



<div style={{width:"90%"}}>

```js

// updater.js

const updateEntity = async () => {
  const entity = new Entity({}); // create the entity
  const updatedEntity = await entity.update({data:"some data"}); // trigger an update to the entity
  return updatedEntity;
}

export default updateEntity;

```

```jsx

// Application.js

import React from 'react';

import updateEntity from './updater'

export default () => (
  <div>
    <button
      onClick={ async () => {
        const updatedEntity = await updateEntity(); // waits for entity to finish updating
        alert(updatedEntity); // then alert the entity update in the UI
      }
    />
  </div>
)

```
</div>

<img style={{width:"90%"}}  src="images/4.png"/>

---

 ### But it's never quite that simple

---


<Image size="50%" src="images/uml.png"/>

---





export default SplitRight



<div style={{width:"90%"}}>


```typescript

// Entity.ts

class Entity<T extends EntityObject> {

  // ...

  get id() {
    return this.key ? this.key.id : null;
  }
}

interface EntLoaderConstructor<D extends object, T extends Entity<D>> {
  new (): EntLoader<D, T>;
}

abstract class EntLoader<D extends object, T extends Entity<D>> {
  abstract async fromId(
    id: string | number | PathElement[],
    req: IViewerContext
  ): Promise<T>;
}

abstract class EntDataStoreBackedLoader<
  D extends object,
  T extends Entity<D>
> extends EntLoader<D, T> {
  kind: string;
  cls: EntConstructor<D, T>;

  async fromId(id: string | number | PathElement[], req: IViewerContext) {
    return this.fromKey(GCloudDB().key(id), req);
  }
}

```
</div>

<div>

<img style={{width:"90%"}}  src="images/uml.png"/>
</div>


---

<Image size="50%" src="images/5.png"/>

---

export default SplitRight


<div style={{width:"80%"}}>


```typescript

// EntReport

export class EntReportLoader extends EntDataStoreBackedLoader<
  EntReportData,
  EntReport
> {
  kind = 'Report';
  cls = EntReport;
}

```

```typescript

// EntVerifierProfile

export class EntVerifierProfileLoader extends EntDataStoreBackedLoader<
  EntVerifierProfileData,
  EntVerifierProfile
> {
  kind = 'VerifierProfile';
  cls = EntVerifierProfile;
}

export default class EntVerifierProfile extends Entity<EntVerifierProfileData> {
  static kind = 'VerifierProfile';
  async function projectVerificationRequests(reportId) {
    const report = await new ReportLoader().fromId(reportId);
    return report;
  }
}

```

```js

// getReport.js

const getReport = async (verifierId, reportId) => {
  const verifier = await new EntVerifierProfileLoader().fromId(verifierId);
  const [report] = await verifier.projectVerificationRequests(reportId);
  return report;
}

```
</div>

<img style={{width:"90%"}}  src="images/6.png"/>


---





###### Asynchronous calls which depend on the previous call to finish start to quickly add up



```js


const getReport = async (verifierId, reportId) => {
  const verifier = await new EntVerifierProfileLoader().fromId(verifierId);
  const [report] = await verifier.projectVerificationRequests(reportId);
  return report;
}


```

---

Consider this more realistic data relationship interaction

---

<Image size="50%" src="images/7.png"/>

---

<Image size="50%" src="images/8.png"/>

---

~~Creating asynchrony is easy~~

Coordinating asynchrony is hard.

Distributing asynchrony is harder.


---

### Writing asynchronous code is easy, and it's clean.



###### _Until it isn't._


---

<Image size="50%" src="images/micro0.png"/>

---


<Image size="50%" src="images/micro1.png"/>

---



~~Creating asynchrony is easy~~

~~Coordinating asynchrony is hard.~~

Distributing asynchrony is harder.


---

<Image size="50%" src="images/micro2.png"/>

---

<Image size="50%" src="images/micro3.png"/>

---


<Image size="50%" src="images/micro4.png"/>

---

<Image size="50%" src="images/micro5.png"/>

---

At the Macro level, async/await control helps a lot.


###### *But not without a pattern for concurrency*


---

<Image size="50%" src="images/external0.png"/>

---

<Image size="50%" src="images/external1.png"/>

---

<Image size="50%" src="images/external2.png"/>

---

<Image size="50%" src="images/external3.png"/>

---

<Image size="50%" src="images/external4.png"/>

---

<Image size="50%" src="images/external5.png"/>

---

Pattern considerations


---


How can we create patterns for concurrency and asynchronous execution at the microservice level?

---

How can we handle distribution of tasks amongst resources?

---

How do we create consistent error handling?

---

How do we create a completely non-blocking workflow?

---

How do we persist context in distributed asynchrony to prevent duplicate work?

---

#### Asynchronous Pattern Exploration

###### Note: condensed code/notes can be found here: https://github.com/jaycenhorton/async-explore

---

# todo: viz

---

# Asynchronous JS

---

#### Async/Await

```js
// async.js
const asyncFunc = async () => {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log('5 second operation finishing in asyncFunc');
      resolve();
    }, 5000);
  });
};
const exec = async time => {
  await asyncFunc();
  setTimeout(() => {
    console.log('Finished 5 second operation in exec');
    const end = process.hrtime.bigint();
    console.log('Benchmark took %d nanoseconds', end - time);
  }, 5000);
};
const time = process.hrtime.bigint();

(async () => exec(time))();
```

```
node --experimental-worker async
Finished 5 second operation in asyncFunc
Finished 5 second operation in exec
Benchmark took 10012905082 nanoseconds
```

<Notes>
  This demonstrates that the second `setTimeout` will not begin to process until
  the first awaited promise is finished
</Notes>

---

# todo: viz

---

#### Promise.all

---

# todo: viz

---

#### JS Proxy patterns

---

#### Async/await in a transparent proxy

```js
function traceMethodCalls(obj) {
  const asyncFuncInProxy = async () =>
    new Promise(resolve => {
      setTimeout(() => {
        console.log('Finished 5 second operation asyncFuncInProxy');
        resolve();
      }, 5000);
    });

  const handler = {
    get(target, propKey, receiver) {
      const targetValue = target[propKey];
      return async function asyncProxy(...args) {
        await asyncFuncInProxy();
        return targetValue.apply(this, args);
      };
    },
  };
  return new Proxy(obj, handler);
}

const obj = {
  async asyncFunc(time) {
    setTimeout(() => {
      console.log('Finished 5 second operation in asyncFunc');
      const end = process.hrtime.bigint();
      console.log(`Benchmark took %d nanoseconds`, end - time);
    }, 5000);
  },
};

const tracedObj = traceMethodCalls(obj);
const time = process.hrtime.bigint();
(async () => tracedObj.asyncFunc(time))();
```

```
node --experimental-worker asyncProxy
Finished 5 second operation asyncFuncInProxy
Finished 5 second operation in asyncFunc
Benchmark took 10008815778 nanoseconds
```

<Notes>
  This demonstrates that the second `setTimeout` will not begin to process until
  the first awaited promise is finished even though the first `setTimeout` only
  exists in the context of the proxy.
</Notes>


---

#### Multithreaded async/await in a proxy

```js
function traceMethodCalls(obj) {
  const handler = {
    get(target, propKey, receiver) {
      const targetValue = target[propKey];
      return async function asyncProxy(...args) {
        (async () => {
          const { job, start, stop } = require('microjob');
          try {
            // start the worker pool
            await start();
            // this function will be executed in another thread
            const resolvedJob = await job(
              async data =>
                new Promise(resolve => {
                  setTimeout(() => {
                    console.log('Finished 5 second operation asyncFuncInProxy');
                    const end = process.hrtime.bigint();
                    resolve(`Benchmark took %d nanoseconds`, end - data.time);
                  }, 5000);
                }),
              { data: { time: args[0] } }
            );
            console.log(resolvedJob);
          } catch (err) {
            console.error(err);
          } finally {
            // shutdown worker pool
            await stop();
          }
        })();
        return targetValue.apply(this, args);
      };
    },
  };
  return new Proxy(obj, handler);
}
```

---

# todo: viz

---

#### Multithreaded async/await in a proxy cont.

```js
const obj = {
  async asyncFunc(time) {
    return new Promise(resolve => {
      setTimeout(() => {
        console.log('Finished 5 second operation in asyncFunc');
        resolve();
      }, 5000);
    });
  },
};

const tracedObj = traceMethodCalls(obj);
const time = process.hrtime.bigint();
(async () => tracedObj.asyncFunc(time))();
```

```
node --experimental-worker asyncProxyThread
Finished 5 second operation in asyncFunc
Finished 5 second operation asyncFuncInProxy
Benchmark took 5108165406 nanoseconds
```

---

# todo: viz

---

#### Proxy publisher

---

# todo: viz

---

# The end
